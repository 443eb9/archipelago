# 噪声

整合一下各种噪声算法。嗯，就是这样。

> *吵死了！！*

## 前期准备

使用Bevy 0.13.2进行可视化，所以就随便搓一个后处理的框架然后用Shader直接渲染到屏幕上~

因此，下文中 `noise_main` 函数的第一个输入 `p` 都是 `uv * aspect` 。

## 值噪声 Value Noise

> *Value noise is a type of noise commonly used as a procedural texture primitive in computer graphics.* --WikiPedia

值噪声本质上就是将整块屏幕分割为很多格子，每个格子的每个顶点有一个噪声值，之后对于每一个在格子内的点，利用该点在格子内的相对位置插值，即可得到值噪声。

```rust
fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    let t = fract(np);
    let p0 = floor(np);

    return mix(
        mix(hash12(p0), hash12(p0 + vec2f(1., 0.)), t.x),
        mix(hash12(p0 + vec2f(0., 1.)), hash12(p0 + vec2f(1., 1.)), t.x),
        t.y
    );
}
```

于是就会得到这个：

![](https://oss.443eb9.dev/islandsmedia/5/value_linear.png)

效果看着...一言难尽，因为我们使用的是线性插值，解决方案也很简单，使用非线性的插值函数，例如内置的 `smoothstep` 。

```diff
fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
-   let t = fract(np);
+   let t = smoothstep(vec2f(0.), vec2f(1.), fract(np));
    let p0 = floor(np);

    ...
}
```

![](https://oss.443eb9.dev/islandsmedia/5/value_smoothstep.png)

`smoothstep` 函数的实现其实很简单：

$$
f(x)=(3-2x)x^2
$$

## 柏林噪声 Perlin Noise

> *Perlin noise is a type of gradient noise developed by Ken Perlin in 1983* -- WikiPedia

在柏林噪声生成前，我们依然需要把整个空间划分，如图，与值噪声不同的是，这次在每个顶点上的是一个 *梯度向量* 。而梯度向量（红色）与对应的偏移向量（绿色）的点积，替代了值噪声中的随机数。

![](https://oss.443eb9.dev/islandsmedia/5/perlin_explaination.png)

```rust
fn dot_gradiant(p0: vec2f, p: vec2f) -> f32 {
    return dot(hash22(p0) * vec2f(2.) - vec2f(1.), p - p0);
}

fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    let tx = fract(np).x;
    let ty = fract(np).y;
    let p0 = floor(np);

    return mix(
        mix(dot_gradiant(p0, np), dot_gradiant(p0 + vec2f(1., 0.), np), tx),
        mix(dot_gradiant(p0 + vec2f(0., 1.), np), dot_gradiant(p0 + vec2f(1.), np), tx),
        ty
    );
}
```

![](https://oss.443eb9.dev/islandsmedia/5/perlin_linear.png)

哎，结果还是不太行，这是因为线性插值时，每个顶点的权重变化随着距离是线性的，也就是 $f(x)=x$ ，它的导数值在边界处会发生突变，导致噪声值不够丝滑。为了解决这个问题，Ken Perlin整了个 `Fade` 函数，也就是

$$
f(x)=6x^5-15x^4+10x^3
$$

它的一，二阶导函数在0，1处都不会发生突变。至于为什么对二阶导函数也有要求，是因为在使用噪声值作为高度图进行光照的计算时，需要计算法线，而法线的计算需要先计算切线，计算切线就需要求导。这部分待会会提到。

先来改进一下现在的算法吧：

```diff
...

+ fn fade(x: f32) -> f32 {
+     return 6. * pow(x, 5.) - 15. * pow(x, 4.) + 10. * pow(x, 3.);
+ }

fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
-   let tx = fract(np).x;
-   let ty = fract(np).y;
+   let tx = fade(fract(np).x);
+   let ty = fade(fract(np).y);
    let p0 = floor(np);

    ...
}
```

![](https://oss.443eb9.dev/islandsmedia/5/perlin_fade.png)

## 单形噪声 Simplex Noise

> *Simplex noise is the result of an n-dimensional noise function comparable to Perlin noise ("classic" noise) but with fewer directional artifacts, in higher dimensions, and a lower computational overhead.* --WikiPedia

先上动画：

<video controls>
    <source src="https://oss.443eb9.dev/islandsmedia/5/simplex_intro.mp4" type="video/mp4">
</video>

单形噪声使用的三角形比柏林噪声使用的矩形顶点更少，但是会多一些*人工计算*的部分。可以看到，动画里出现了两种坐标系，因为只有在方形的坐标系下，才可以确定这个点属于哪一个格子。那么既然出现了两个不同的坐标系，那么就需要计算他们之间的变换的公式了。

把变换前方形的坐标系叫x-y坐标系，变换后的叫u-v坐标系。首先，让我们计算一下 $(x, y)$ 与 $(u, v)$ 间相互转换的公式。

假设在x-y坐标系中，沿x，y轴的基向量为 $(x, 0)$ ， $(0, y)$ ，同样在x-y坐标系中，沿u，v轴的基向量为 $(a, b)$ ， $(b, a)$ 。

我们目前的目标是，将一个在x-y坐标系中，坐标为 $(x, y)$ 的点变换到在u-v坐标系中的坐标 $(u, v)$ ，也就是动画里在做的事情。

做基变换，可得

$$
\begin{bmatrix}
    x \\ y
\end{bmatrix}
=
\begin{bmatrix}
    a & b \\
    b & a \\
\end{bmatrix}
\begin{bmatrix}
    u \\ v
\end{bmatrix}
=
\begin{bmatrix}
    au + bv \\ bu + av
\end{bmatrix}
$$

也就是

$$
\left\{
\begin{aligned}
    x = au + bv \\
    y = bu + av
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
    x = au - bu + bu + bv \\
    y = bu + bv - bv + av
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
    x = (a - b)u + b(u + v) \\
    y = (a - b)v + b(u + v)
\end{aligned}
\right.
$$

由于 $(a, b)$ 和 $(b, a)$ 是任意的，只要在u-v坐标系的轴上就可以，因此可以假设 $a - b = 1$ ，此处的 $1$ 实际上代表这两个向量被缩放的程度。将其代入，得

$$
\left\{
\begin{aligned}
    x = u + b(u + v) \\
    y = v + b(u + v)
\end{aligned}
\right.
$$

由于晶格都是等边三角形，因此可知

$$
||(a, b) + (b, a)|| = ||(a, b)||
$$

代入 $a - b = 1$ 消去 $a$ ，可得

$$
6b^2 + 6b + 1 = 0
$$

解得

$$
b = \frac{-3 + \sqrt{3}}{6}
$$

我们把这个 $b$ 重命名成 $G$ 。接下来还需要反过来的变换，但是就像这里，我们不希望出现矩阵操作，所以继续推。

$$
\left\{
\begin{aligned}
    x = au + bv \\
    y = bu + av
\end{aligned}
\right.
$$

$$
\left\{
\begin{aligned}
    ax = a^2u + abv \\
    by = b^2u + abv
\end{aligned}
\right.
$$

两式相减得

$$
ax - by = a^2u - b^u
$$

代入 $a - b = 1$ ，消去 $a$

$$
(2b + 1)u = (b + 1)x - by
$$

$$
(2b + 1)u = (2b + 1)x - b(x + y)
$$

$$
u = x - \frac{b}{2b + 1}(x + y)
$$

同理

$$
v = y - \frac{b}{2b + 1}(x + y)
$$

$$
-\frac{1}{2b + 1} = \frac{\frac{-3 + \sqrt{3}}{6}}{1 + 2 * \frac{-3 + \sqrt{3}}{6}} = \frac{\sqrt{3} - 1}{2}
$$

将其命名为 $F$

现在我们已经有了变换公式，接下来让我们把视线聚焦于单个格子

![](https://oss.443eb9.dev/islandsmedia/5/simplex_explaination.png)

现在，每个顶点的权重值，可以用他们与 $p$ 的距离表示，同样，这个函数必须满足一、二阶导数连续。

$$
f(x) = (r^2 - d^2)^4
$$

$r$ 为红色圆的半径，$d$ 为 $p$ 到那个顶点的距离。

接下来就和柏林噪声几乎一模一样了，那么直接上代码

```rust
// xy -> uv
const F = 0.3660254037;
// uv -> xy
const G = -0.211324865;

fn dot_gradiant(p0: vec2f, o: vec2f) -> f32 {
    return dot(normalize(hash22(p0) * vec2f(2.) - vec2f(1.)), o);
}

fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    
    // Skew to figure out the cell id
    let coe1 = F * (np.x + np.y);
    let sp = np + vec2f(coe1);
    let cell_id = floor(sp);

    let coe2 = G * (cell_id.x + cell_id.y);

    // v = vertex, o = offset, d = squared distance

    // Now skew it back
    let v0 = cell_id + vec2f(coe2);
    let o0 = np - v0;
    let d0 = dot(o0, o0);

    var dx = 0.;
    var dy = 1.;
    if o0.x > o0.y {
        dx = 1.;
        dy = 0.;
    }

    let v1 = v0 + vec2f(dx, dy) + vec2f(G);
    let o1 = np - v1;
    let d1 = dot(o1, o1);

    let v2 = v0 + vec2f(1.) + vec2f(2. * G);
    let o2 = np - v2;
    let d2 = dot(o2, o2);

    var n0 = 0.;
    if d0 < 0.5 {
        n0 = dot_gradiant(v0, o0) * pow(0.5 - d0, 4.);
    }

    var n1 = 0.;
    if d1 < 0.5 {
        n1 = dot_gradiant(v1, o1) * pow(0.5 - d1, 4.);
    }

    var n2 = 0.;
    if d2 < 0.5 {
        n2 = dot_gradiant(v2, o2) * pow(0.5 - d2, 4.);
    }

    return 70. * (n0 + n1 + n2);
}
```

看不懂？没关系，上动画！

<video controls>
    <source src="https://oss.443eb9.dev/islandsmedia/5/simplex_explaination.mp4" type="video/mp4">
</video>

不过动画里其实忽略了一些细节，比如就是最后的那个 `70` 到底是怎么来的，还有为什么最大距离是 `0.5` 。其实我也不知道，以后再证吧（逃
