# 噪声

整合一下各种噪声算法。嗯，就是这样。

> *吵死了！！*

## 前期准备

使用Bevy 0.13.2进行可视化，所以就随便搓一个后处理的框架然后用Shader直接渲染到屏幕上~

因此，下文中 `noise_main` 函数的第一个输入 `p` 都是 `uv * aspect` 。

## 值噪声 Value Noise

> *Value noise is a type of noise commonly used as a procedural texture primitive in computer graphics.* --WikiPedia

值噪声本质上就是将整块屏幕分割为很多格子，每个格子的每个顶点有一个噪声值，之后对于每一个在格子内的点，利用该点在格子内的相对位置插值，即可得到值噪声。

```rust
fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    let t = fract(np);
    let p0 = floor(np);

    return mix(
        mix(hash12(p0), hash12(p0 + vec2f(1., 0.)), t.x),
        mix(hash12(p0 + vec2f(0., 1.)), hash12(p0 + vec2f(1., 1.)), t.x),
        t.y
    );
}
```

于是就会得到这个：

![](https://img2.imgtp.com/2024/05/08/HhOpP0Q9.png)

效果看着...一言难尽，因为我们使用的是线性插值，解决方案也很简单，使用非线性的插值函数，例如内置的 `smoothstep` 。

```diff
fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
-   let t = fract(np);
+   let t = smoothstep(vec2f(0.), vec2f(1.), fract(np));
    let p0 = floor(np);

    ...
}
```

![](https://img2.imgtp.com/2024/05/08/4052Y0iw.png)

`smoothstep` 函数的实现其实很简单：

$$
f(x)=(3-2x)x^2
$$

## 柏林噪声 Perlin Noise

> *Perlin noise is a type of gradient noise developed by Ken Perlin in 1983* -- WikiPedia

在柏林噪声生成前，我们依然需要把整个空间划分，如图，与值噪声不同的是，这次在每个顶点上的是一个 *梯度向量* 。而梯度向量（红色）与对应的偏移向量（绿色）的点积，替代了值噪声中的随机数。

![](https://img2.imgtp.com/2024/05/09/W0VW41GG.png)

```rust
fn dot_gradiant(p0: vec2f, p: vec2f) -> f32 {
    return dot(hash22(p0) * vec2f(2.) - vec2f(1.), p - p0);
}

fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    let tx = fract(np).x;
    let ty = fract(np).y;
    let p0 = floor(np);

    return mix(
        mix(dot_gradiant(p0, np), dot_gradiant(p0 + vec2f(1., 0.), np), tx),
        mix(dot_gradiant(p0 + vec2f(0., 1.), np), dot_gradiant(p0 + vec2f(1.), np), tx),
        ty
    );
}
```

![](https://img2.imgtp.com/2024/05/09/n4hxtmYf.png)

哎，结果还是不太行，这是因为线性插值时，每个顶点的权重变化随着距离是线性的，也就是 $f(x)=x$ ，它的导数值在边界处会发生突变，导致噪声值不够丝滑。为了解决这个问题，Ken Perlin整了个 `Fade` 函数，也就是

$$
f(x)=6x^5-15x^4+10x^3
$$

它的一，二阶导函数在0，1处都不会发生突变。至于为什么对二阶导函数也有要求，是因为在使用噪声值作为高度图进行光照的计算时，需要计算法线，而法线的计算需要先计算切线，计算切线就需要求导。这部分待会会提到。

先来改进一下现在的算法吧：

```diff
...

+ fn fade(x: f32) -> f32 {
+     return 6. * pow(x, 5.) - 15. * pow(x, 4.) + 10. * pow(x, 3.);
+ }

fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
-   let tx = fract(np).x;
-   let ty = fract(np).y;
+   let tx = fade(fract(np).x);
+   let ty = fade(fract(np).y);
    let p0 = floor(np);

    ...
}
```

![](https://img2.imgtp.com/2024/05/09/XcISqmUM.png)
