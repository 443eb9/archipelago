# 噪声

整合一下各种噪声算法。嗯，就是这样。

> *吵死了！！*

## 前期准备

使用Bevy 0.13.2进行可视化，所以就随便搓一个后处理的框架然后用Shader直接渲染到屏幕上~

因此，下文中 `noise_main` 函数的第一个输入 `p` 都是 `uv * aspect` 。

## 值噪声 Value Noise

> *Value noise is a type of noise commonly used as a procedural texture primitive in computer graphics.* --WikiPedia

值噪声本质上就是将整块屏幕分割为很多格子，每个格子的每个顶点有一个噪声值，之后对于每一个在格子内的点，利用该点在格子内的相对位置插值，即可得到值噪声。

```rust
fn noise_main(p: vec2f, settings: NoiseSettings) -> f32 {
    let np = p * settings.scale;
    let t = fract(np);
    let p0 = floor(np);

    return mix(
        mix(hash12(p0), hash12(p0 + vec2f(1., 0.)), t.x),
        mix(hash12(p0 + vec2f(0., 1.)), hash12(p0 + vec2f(1., 1.)), t.x),
        t.y
    );
}
```

于是就会得到这个：

![](https://img2.imgtp.com/2024/05/08/HhOpP0Q9.png)

效果看着...一言难尽，因为我们使用的是线性插值，解决方案也很简单，使用非线性的插值函数，例如内置的 `smoothstep` 。

```diff
- let t = fract(np);
+ let t = smoothstep(vec2f(0.), vec2f(1.), fract(np));
```

![](https://img2.imgtp.com/2024/05/08/4052Y0iw.png)

`smoothstep` 函数的实现其实很简单：

$$
f=x*x*(3-2x)
$$

> *记住这个函数，待会还会用。*

## 柏林噪声 Perlin Noise

> *Perlin noise is a type of gradient noise developed by Ken Perlin in 1983* -- WikiPedia
